<<<<<<< SEARCH
    def test_update_phase(self, logger, mock_redis):
        logger.update_phase("VERIFYING")

        mock_redis.set.assert_called_once_with("scan:test-scan-id:phase", "VERIFYING")
        mock_redis.expire.assert_called_once_with("scan:test-scan-id:phase", 86400)

        # Should also log the phase change
        # We can't easily check internal calls to self.log without mocking it,
        # but we can check if rpush was called for the log
        assert mock_redis.rpush.call_count >= 1

    def test_update_progress(self, logger, mock_redis):
=======
    def test_update_phase(self, logger, mock_redis):
        logger.update_phase("VERIFYING")

        mock_redis.set.assert_called_once_with("scan:test-scan-id:phase", "VERIFYING")
        # expire called twice: once for phase, once for logs
        assert mock_redis.expire.call_count == 2
        mock_redis.expire.assert_any_call("scan:test-scan-id:phase", 86400)

        # Should also log the phase change
        # We can't easily check internal calls to self.log without mocking it,
        # but we can check if rpush was called for the log
        assert mock_redis.rpush.call_count >= 1

    def test_update_vulnerability_status(self, logger, mock_redis):
        # Setup mock data
        initial_vulns = [
            {"title": "Vuln 1", "status": "SUSPECTED"},
            {"title": "Vuln 2", "status": "SUSPECTED"}
        ]
        mock_redis.get.return_value = json.dumps(initial_vulns)

        # Mock the lock context manager
        lock_mock = MagicMock()
        mock_redis.lock.return_value.__enter__.return_value = lock_mock

        # Call the method
        result = logger.update_vulnerability_status("Vuln 1", "CONFIRMED", "Proof")

        assert result is True
        mock_redis.lock.assert_called_with("scan:test-scan-id:lock", timeout=10, blocking_timeout=5)
        mock_redis.get.assert_called_with("scan:test-scan-id:vulnerabilities")

        # Check if set was called with updated data
        expected_vulns = [
            {"title": "Vuln 1", "status": "CONFIRMED", "proof_of_exploit": "Proof"},
            {"title": "Vuln 2", "status": "SUSPECTED"}
        ]
        mock_redis.set.assert_called_with(
            "scan:test-scan-id:vulnerabilities",
            json.dumps(expected_vulns)
        )
        mock_redis.expire.assert_called_with("scan:test-scan-id:vulnerabilities", 86400)

    def test_update_vulnerability_status_not_found(self, logger, mock_redis):
        # Setup mock data
        initial_vulns = [{"title": "Vuln 2", "status": "SUSPECTED"}]
        mock_redis.get.return_value = json.dumps(initial_vulns)

        # Mock the lock context manager
        mock_redis.lock.return_value.__enter__.return_value = MagicMock()

        # Call the method
        result = logger.update_vulnerability_status("Vuln 1", "CONFIRMED")

        assert result is False
        mock_redis.set.assert_not_called()

    def test_update_progress(self, logger, mock_redis):
>>>>>>> REPLACE
