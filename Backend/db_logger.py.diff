<<<<<<< SEARCH
    def save_vulnerabilities(self, vulnerabilities: list):
        """
        Save found vulnerabilities to Redis.
        """
        key = f"scan:{self.scan_id}:vulnerabilities"
        # Serialize list of dicts to JSON string
        self.redis_client.set(key, json.dumps(vulnerabilities))
        self.redis_client.expire(key, 86400)

    def update_phase(self, phase: str):
=======
    def save_vulnerabilities(self, vulnerabilities: list):
        """
        Save found vulnerabilities to Redis.
        """
        key = f"scan:{self.scan_id}:vulnerabilities"
        # Serialize list of dicts to JSON string
        self.redis_client.set(key, json.dumps(vulnerabilities))
        self.redis_client.expire(key, 86400)

    def update_vulnerability_status(self, title: str, status: str, proof: str = None):
        """
        Atomically updates a vulnerability's status and proof.
        """
        key = f"scan:{self.scan_id}:vulnerabilities"
        lock_key = f"scan:{self.scan_id}:lock"  # Use a consistent lock key for the scan

        try:
            with self.redis_client.lock(lock_key, timeout=10, blocking_timeout=5):
                current_data = self.redis_client.get(key)
                if not current_data:
                    return False

                vulnerabilities = json.loads(current_data)
                found = False

                for v in vulnerabilities:
                    if v.get("title") == title:
                        v["status"] = status
                        if proof:
                            v["proof_of_exploit"] = proof
                        found = True
                        break  # Update first match

                if found:
                    self.redis_client.set(key, json.dumps(vulnerabilities))
                    # Preserve TTL if possible, or reset to 24h
                    self.redis_client.expire(key, 86400)
                    return True
                return False
        except redis.exceptions.LockError:
            self.log("ERROR", f"Could not acquire lock to update vulnerability: {title}")
            return False

    def update_phase(self, phase: str):
>>>>>>> REPLACE
